-- Sync.lua - –ú–æ–¥—É–ª—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Remo
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local include = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("include")

local Remo = require(include:WaitForChild("remo")) -- –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π –ø—É—Ç—å –∫ Remo
local t = require(include:WaitForChild("t")) -- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
local Proxy = require(include:WaitForChild("Proxy")) -- –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π –ø—É—Ç—å

type Remotes = {
    syncData: Remo.ServerToClient<{path: {any}, patch: any, isFullSync: boolean?}>,
    requestSync: Remo.ClientToServer<{}>
}

local remotes: Remotes = Remo.createRemotes({
    syncData = Remo.remote(),
    requestSync = Remo.remote()
})

-- –°–µ—Ä–≤–µ—Ä–Ω–∞—è —á–∞—Å—Ç—å
local ServerSync = {}
ServerSync.__index = ServerSync

function ServerSync.new(proxyTable, player)
    local self = setmetatable({}, ServerSync)
    self.proxyTable = proxyTable
    self.player = player
    self.isSyncing = false
    self.isDestroyed = false
    
    -- –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
    self.unsubscribe = Proxy.subscribe(proxyTable, {}, function(oldValue, newValue, path)
        if self.isSyncing or self.isDestroyed then return end
        
        -- –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ –ø—É—Ç–∏ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
        local value = proxyTable
        for _, key in ipairs(path) do
            if type(value) ~= "table" then break end
            value = value[key]
        end
        
        remotes.syncData:fire(self.player, {
            path = path,
            patch = Proxy.deepCopy(value),
            isFullSync = false
        })
    end)
    
    -- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤
    self.requestConnection = remotes.requestSync:connect(function(requestPlayer)
        if requestPlayer == player and not self.isDestroyed then
            self:sendFullState()
        end
    end)
    
    return self
end

function ServerSync:sendFullState()
    if self.isDestroyed then return end
    self.isSyncing = true
    remotes.syncData:fire(self.player, {
        path = {},
        patch = Proxy.deepCopy(self.proxyTable.__source),
        isFullSync = true
    })
    self.isSyncing = false
end

function ServerSync:destroy()
    self.isDestroyed = true
    if self.unsubscribe then
        self.unsubscribe()
        self.unsubscribe = nil
    end
    if self.requestConnection then
        self.requestConnection:Disconnect()
        self.requestConnection = nil
    end
end

-- –ö–ª–∏–µ–Ω—Ç—Å–∫–∞—è —á–∞—Å—Ç—å
local ClientSync = {}
ClientSync.__index = ClientSync

function ClientSync.new(proxyTable)
    local self = setmetatable({}, ClientSync)
    self.proxyTable = proxyTable
    self.isInitialized = false
    self.isDestroyed = false
    
    -- –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    self.syncConnection = remotes.syncData:connect(function(data)
        if self.isDestroyed then return end
        self:applyData(data)
    end)
    
    remotes.requestSync:fire()
    return self
end

-- –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –ß–ï–†–ï–ó –ü–†–û–ö–°–ò, –∞ –Ω–µ –Ω–∞–ø—Ä—è–º—É—é –∫ __source
function ClientSync:applyData(data)
    if self.isDestroyed then return end

    if data.isFullSync then
        self.isInitialized = false
        Proxy.batch(self.proxyTable, function()
            -- –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (–∫—Ä–æ–º–µ __source)
            for k in pairs(self.proxyTable) do
                if k ~= "__source" then
                    self.proxyTable[k] = nil
                end
            end
            -- –ü—Ä–∏–º–µ–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
            for k, v in pairs(data.patch) do
                if k ~= "__source" then
                    self.proxyTable[k] = Proxy.deepCopy(v)
                end
            end
        end)
        self.isInitialized = true
        print("[CLIENT] ‚úÖ –ü–æ–ª–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞")
    else
        if not self.isInitialized then
            print("[CLIENT] ‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —á–∞—Å—Ç–∏—á–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ")
            return
        end

        -- üî• –ö–õ–Æ–ß–ï–í–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–∏–º–µ–Ω—è–µ–º –ß–ï–†–ï–ó –ü–†–û–ö–°–ò, –Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º clean –¥–∞–Ω–Ω—ã–µ
        local path = data.path
        if #path == 0 then
            -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ—Ä–Ω—è
            Proxy.batch(self.proxyTable, function()
                for k, v in pairs(data.patch) do
                    if k ~= "__source" then
                        self.proxyTable[k] = Proxy.deepCopy(v)
                    end
                end
            end)
        else
            -- –ò–¥–µ–º –ø–æ –ø—É—Ç–∏ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
            local target = self.proxyTable
            for i = 1, #path - 1 do
                local key = path[i]
                if type(target) ~= "table" then
                    error("Invalid path")
                    return
                end
                if target[key] == nil then
                    target[key] = {}
                elseif type(target[key]) ~= "table" then
                    target[key] = {}
                end
                target = target[key]
            end

            -- –ü—Ä–∏–º–µ–Ω—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –∫ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É –∫–ª—é—á—É
            local lastKey = path[#path]
            if lastKey ~= nil then
                local cleanValue = Proxy.deepCopy(data.patch)  -- –£–±–∏—Ä–∞–µ–º __source!
                Proxy.batch(self.proxyTable, function()
                    target[lastKey] = cleanValue
                end)
            end
        end
        print(`[CLIENT] ‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ –ø–æ –ø—É—Ç–∏: {table.concat(path, " ‚Üí ")}`)
    end
end

function ClientSync:destroy()
    self.isDestroyed = true
    if self.syncConnection then
        self.syncConnection:Disconnect()
        self.syncConnection = nil
    end
end

return {
    Server = ServerSync,
    Client = ClientSync,
    remotes = remotes
}